-- –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—É—Ç–µ–π –∫ –º–æ–¥—É–ª—è–º
package.path = package.path .. ";./?.lua;../?.lua;D:/unic6/demo/Maze&cats_LUA/?.lua"

-- –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
local socket = require("socket")
local json = require("dkjson")
local common = require("game_common")
local logger = require("logger")

-- –õ–æ–≥–≥–µ—Ä
logger.init("D:/unic6/demo/Maze&cats_LUA/server_log.txt")
logger.log("üöÄ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...")

-- –°–µ—Ä–≤–µ—Ä–Ω—ã–π –æ–±—ä–µ–∫—Ç
local server = {
    listener = nil,
    connections = {},
    clientToPlayerId = {},
    players = {},
    grid = {},
    tunnelStats = {},
    tunnelIdCounter = 1,
    currentPlayerIndex = 1,
    drawnCard = nil,
    GRID_SIZE = 25
}
--–Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è —Å–µ—Ä–≤–µ—Ä–∞
function server.start()
    server.listener = socket.bind("*", 22122)
    server.listener:settimeout(0)
     logger.log("üöÄ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω–æ")
    for y = 1, server.GRID_SIZE do
        server.grid[y] = {}
        for x = 1, server.GRID_SIZE do
            server.grid[y][x] = {
                type = "void",
                rotation = 0,
                occupied = false
            }
        end
    end

    server.drawnCard = server.drawRandomCard()
end

--–°–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—è —Å—Ç–∞–Ω—É –≥—Ä–∏
function server.serializeState()
    local gridCopy = deepCopyGrid(server.grid)
    local playersCopy = {}
    for i, p in ipairs(server.players) do
        local handCopy = {}
        for _, c in ipairs(p.hand or {}) do
            table.insert(handCopy, {
                type = c.type,
                rotation = c.rotation,
                x = c.x or 0,
                y = c.y or 0,
                hover = c.hover or false
            })
        end

        playersCopy[i] = {
            x = p.x, y = p.y,
            hand = handCopy,
            color = p.color,
            turnStage = p.turnStage,
            placedCard = p.placedCard
        }
    end

    return json.encode({
        grid = gridCopy,
        players = playersCopy,
        currentPlayerIndex = server.currentPlayerIndex,
    })
end

function server.broadcastGameState()
    local json = require("dkjson")

    for i, c in ipairs(server.connections) do
        local baseState = server.serializeState()
        local parsed = json.decode(baseState)

        -- –î–æ–±–∞–≤–ª—è–µ–º drawnCard —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω–æ–º—É –∏–≥—Ä–æ–∫—É
        if i == server.currentPlayerIndex and server.drawnCard then
            parsed.drawnCard = server.drawnCard
        end

        local personalized = json.encode(parsed)
        c:send("SYNC:" .. personalized .. "\n")
    end
end

function broadcastExcept(excludeClient, message)
    for _, c in ipairs(server.connections) do
        if c ~= excludeClient then c:send(message) end
    end
end

--–û–Ω–æ–≤–ª–µ–Ω–Ω—è —Å—Ç–∞–Ω—É —Å–µ—Ä–≤–µ—Ä–∞ (–ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è —Ç–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è)
function server.update()
    logger.log("[SERVER] update()")
    local conn = server.listener:accept()
    if conn then
        logger.log("[SERVER] –ù–æ–≤–µ –∑'—î–¥–Ω–∞–Ω–Ω—è")
        conn:settimeout(0)
        table.insert(server.connections, conn)
        local id = #server.players + 1
        server.addNewPlayer()
        logger.log("–ù–æ–≤–µ –∑'—î–¥–Ω–∞–Ω–Ω—è. –í—Å—å–æ–≥–æ –≥—Ä–∞–≤—Ü—ñ–≤: " .. #server.players)
        server.clientToPlayerId[conn] = id
        conn:send("YOURID:" .. id .. "\n")
        logger.log("YOURID: " .. id)
        local state = server.serializeState()
        conn:send("SYNC:" .. state .. "\n")
        server.broadcastGameState()
        logger.log("SYNC –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∫–ª—ñ—î–Ω—Ç—É " .. id)
    end

    for _, c in ipairs(server.connections) do
        local line = c:receive()
        if line then
            logger.log("[SERVER] –í—ñ–¥ –∫–ª—ñ—î–Ω—Ç–∞: " .. tostring(line))
            server.handleMessage(line, c)
        end
    end
end

--–î–æ–¥–∞–≤–∞–Ω–Ω—è –Ω–æ–≤–æ–≥–æ –≥—Ä–∞–≤—Ü—è
function server.addNewPlayer()

    if #server.players >= 4 then return end
    local n = #server.players
    local spawnX, spawnY, rotation
        if n == 0 then
            spawnX, spawnY, rotation = 13, 25, 270
        elseif n == 1 then
            spawnX, spawnY, rotation = 13, 1, 90
        elseif n == 2 then
            spawnX, spawnY, rotation = 25, 13, 180
        elseif n == 3 then
            spawnX, spawnY, rotation = 1, 13, 0
        end

    if not server.grid or not server.grid[spawnY] then
        logger.log("‚ùå –°—ñ—Ç–∫–∞ –Ω–µ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∞ –∞–±–æ spawnY –Ω–µ–¥—ñ–π—Å–Ω–∏–π: " .. tostring(spawnY))
        return
    end
        
    local id = server.tunnelIdCounter
    server.tunnelIdCounter = server.tunnelIdCounter + 1

    server.grid[spawnY][spawnX] = {
        type = "deadend", rotation = rotation,
        tunnelId = id, occupied = false
    }

    local openSides = common.getOpenSides({type = "deadend", rotation = rotation})
    local exitScore = 0
    for _, _ in pairs(openSides) do
        exitScore = exitScore + 1
    end
        logger.log("–°—Ç–∞—Ä—Ç–æ–≤–∏–π —Ç—É–Ω–µ–ª—å " .. id .. " –º–∞—î –≤–∏—Ö—ñ–¥(–∏): " .. exitScore)
    server.tunnelStats[id] = {
        tileCount = 1,
        exitScore = exitScore
        
    }

    local hand = {}
    for i = 1, 6 do
        table.insert(hand, {
            type = common.randomCardType(),
            rotation = 0, x = 0, y = 0, hover = false
        })
    end

    local colors = {{1, 0, 0}, {0, 0, 1}, {0, 1, 0}, {1, 0, 1}}
    table.insert(server.players, {
        x = spawnX, y = spawnY,
        hand = hand,
        color = colors[n + 1],
        turnStage = "place",
        placedCard = false
    })
end

--–û–±—Ä–æ–±–∫–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
function server.handleMessage(msg, client)
    local cmd, data = msg:match("^(%w+):(.*)$")
    local pid = server.clientToPlayerId[client]
    if not pid then return end
    local player = server.players[pid]

 if cmd == "PLACE" then
    -- üåê –†–∞–∑–±–æ—Ä –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
    local parts = {}
    for part in data:gmatch("[^,]+") do
        table.insert(parts, part)
    end

    local x = tonumber(parts[1])
    local y = tonumber(parts[2])
    local tileType = parts[3]
    local rot = tonumber(parts[4])
    local source = parts[5]

    logger.log("üì© PLACE –∑–∞–ø–∏—Ç: type=" .. tostring(tileType) .. ", source=" .. tostring(source))
    if server.drawnCard then
        logger.log("üì¶ drawnCard = " .. server.drawnCard.type)
    else
        logger.log("üì¶ drawnCard = nil")
    end

    -- üîí –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–∞–∑—ã –∏ —Ñ–ª–∞–≥–∞
    if player.turnStage ~= "place" then
        logger.log("‚ùå –ì—Ä–∞–≤–µ—Ü—å –Ω–µ –≤ —Ñ–∞–∑—ñ place")
        client:send("RESULT:ERR\n")
        return
    end

    if player.placedCard then
        logger.log("‚ùå –ì—Ä–∞–≤–µ—Ü—å –≤–∂–µ —Ä–æ–∑–º—ñ—Å—Ç–∏–≤ –∫–∞—Ä—Ç—É –≤ —Ü—å–æ–º—É —Ö–æ–¥—ñ")
        client:send("RESULT:ERR\n")
        return
    end

    if not common.isPlacementValid(server.grid, server.tunnelStats, x, y, tileType, rot) then
        logger.log("‚ùå –†–æ–∑–º—ñ—â–µ–Ω–Ω—è –Ω–µ–¥—ñ–π—Å–Ω–µ: " .. x .. "," .. y .. " —Ç–∏–ø=" .. tileType .. " rot=" .. rot)
        client:send("RESULT:ERR\n")
        return
    end

    -- ‚úÖ –†–æ–∑–º—ñ—â–µ–Ω–Ω—è –∫–∞—Ä—Ç–∏
    logger.log("‚úÖ –ì—Ä–∞–≤–µ—Ü—å " .. pid .. " —Å—Ç–∞–≤–∏—Ç—å " .. tileType .. " –Ω–∞ (" .. x .. "," .. y .. ")")
    server.applyPlacement(pid, x, y, tileType, rot)

    local removedFromHand = false
    if source == "D" and server.drawnCard and server.drawnCard.type == tileType then
        logger.log("üß∫ –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–æ drawnCard: " .. tileType)
        server.drawnCard = nil
        removedFromHand = true
    else
        local idx = tonumber(source)
        if idx and player.hand[idx] and player.hand[idx].type == tileType then
            table.remove(player.hand, idx)
            logger.log("üß∫ –í–∏–¥–∞–ª–µ–Ω–æ –∫–∞—Ä—Ç—É –∑ —Ä—É–∫–∏: " .. tileType .. " (–ø–æ–∑–∏—Ü—ñ—è " .. idx .. ")")
            removedFromHand = true
        end
    end

    player.placedCard = true

    client:send("RESULT:OK\n")
    server.broadcastGameState()

    elseif cmd == "MOVE" then
        if player.turnStage ~= "move" then
            logger.log("‚ùå –ì—Ä–∞–≤–µ—Ü—å " .. pid .. " –Ω–∞–º–∞–≥–∞—î—Ç—å—Å—è —Ä—É—Ö–∞—Ç–∏—Å—è –Ω–µ —É —Ñ–∞–∑—ñ move")
            client:send("RESULT:ERR\n")
            return
        end

        local x, y = data:match("^(%d+),(%d+)$")
        x, y = tonumber(x), tonumber(y)

        if not x or not y then
            logger.log("‚ùå –ù–µ–≤—ñ—Ä–Ω—ñ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ —É MOVE")
            client:send("RESULT:ERR\n")
            return
        end

        if not common.canMove(server.grid, player.x, player.y, x, y) then
            logger.log("‚ùå –ü–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è –Ω–µ–¥—ñ–π—Å–Ω–µ: " .. player.x .. "," .. player.y .. " ‚Üí " .. x .. "," .. y)
            client:send("RESULT:ERR\n")
            return
        end

        logger.log("üö∂ –ì—Ä–∞–≤–µ—Ü—å " .. pid .. " –ø–µ—Ä–µ–º—ñ—Å—Ç–∏–≤—Å—è –Ω–∞ " .. x .. "," .. y)
        player.x = x
        player.y = y
        player.turnStage = "done"

        client:send("RESULT:OK\n")
        server.broadcastGameState()

    elseif cmd == "ENDTURN" then
        logger.log("–ì—Ä–∞–≤–µ—Ü—å " .. pid .. " –Ω–∞—Ç–∏—Å–Ω—É–≤ '–ö—ñ–Ω–µ—Ü—å —Ö–æ–¥—É' (—Å—Ç–∞–¥—ñ—è: " .. tostring(player.turnStage) .. ")")
        if player.turnStage == "place" then
            player.turnStage = "move"
            logger.log("üîÑ –ü–µ—Ä–µ—Ö–æ–¥–∏–º–æ –¥–æ —Ñ–∞–∑–∏ –ø–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è")
            server.broadcastGameState()

        elseif player.turnStage == "move" or player.turnStage == "done" then
            logger.log("‚úÖ –ì—Ä–∞–≤–µ—Ü—å " .. pid .. " –∑–∞–≤–µ—Ä—à–∏–≤ —Ö—ñ–¥")

            -- –ü–µ—Ä–µ—Ö–æ–¥–∏–º –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –≥—Ä–∞–≤—Ü—è (–≤ —Ç–æ–º —á–∏—Å–ª–µ —Å–∞–º–æ–≥–æ —Å–µ–±—è)
            server.currentPlayerIndex = server.currentPlayerIndex % #server.players + 1

            local next = server.players[server.currentPlayerIndex]
            if not next then
                logger.log("‚ùå –ù–∞—Å—Ç—É–ø–Ω–æ–≥–æ –≥—Ä–∞–≤—Ü—è –Ω–µ —ñ—Å–Ω—É—î! –ü–æ—Ç–æ—á–Ω–∏–π —ñ–Ω–¥–µ–∫—Å: " .. tostring(server.currentPlayerIndex))
                return
            end

            next.turnStage = "place"
            next.placedCard = false
            server.drawnCard = server.drawRandomCard()

            logger.log("üéØ –•—ñ–¥ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å –¥–æ –≥—Ä–∞–≤—Ü—è " .. tostring(server.currentPlayerIndex))
            server.broadcastGameState()
        end  

    elseif cmd == "TAKECARD" then
        if player.turnStage ~= "place" then
            logger.log("‚ùå –ù–µ –º–æ–∂–Ω–∞ –≤–∑—è—Ç–∏ –∫–∞—Ä—Ç—É –Ω–µ —É —Ñ–∞–∑—ñ 'place'")
            client:send("RESULT:ERR\n")
            return
         end

         if not server.drawnCard then
            logger.log("‚ùå –ù–µ–º–∞—î –≤–∏—Ç—è–≥–Ω—É—Ç–æ—ó –∫–∞—Ä—Ç–∏")
            client:send("RESULT:ERR\n")
            return
        end

        local target = data:match("^(%w+)$")
        if target == "X" then
            logger.log("üóëÔ∏è –ì—Ä–∞–≤–µ—Ü—å –≤—ñ–¥–º–æ–≤–∏–≤—Å—è –≤—ñ–¥ –∫–∞—Ä—Ç–∏")
            server.drawnCard = nil
        elseif tonumber(target) and tonumber(target) >= 1 and tonumber(target) <= 6 then
            local i = tonumber(target)
            if #player.hand < 6 then
                table.insert(player.hand, i, server.drawnCard)
                logger.log("üì• –ì—Ä–∞–≤–µ—Ü—å –ø–æ–∫–ª–∞–≤ –∫–∞—Ä—Ç—É —É —Ä—É–∫—É –≤ —Å–ª–æ—Ç " .. i)
                server.drawnCard = nil
            else
                logger.log("‚ùå –†—É–∫–∞ –ø–æ–≤–Ω–∞")
                client:send("RESULT:ERR\n")
                return
            end
        end
        server.broadcastGameState()
    elseif cmd == "EXIT" then
            logger.log("üõë –û—Ç—Ä–∏–º–∞–Ω–æ EXIT ‚Äî –∑—É–ø–∏–Ω–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞")
            os.exit()
            elseif cmd == "START" then
        logger.log("üéÆ –•–æ—Å—Ç —Ä–æ–∑–ø–æ—á–∏–Ω–∞—î –≥—Ä—É")

        server.currentPlayerIndex = 1

        for i, p in ipairs(server.players) do
            p.turnStage = "wait"
            p.placedCard = false
        end

        server.players[1].turnStage = "place"
        server.drawnCard = server.drawRandomCard()

        for _, c in ipairs(server.connections) do
            c:send("START:\n")
        end

        server.broadcastGameState()
    end
end

-- –†–æ–∑–º—ñ—â–µ–Ω–Ω—è –ø–ª–∏—Ç–∫–∏
function server.applyPlacement(pid, x, y, tileType, rotation)
    local player = server.players[pid]
    local grid = server.grid

    grid[y][x].type = tileType
    grid[y][x].rotation = rotation
    player.placedCard = true

    local neighbors = {}
    for _, dir in ipairs({{0, -1}, {0, 1}, {-1, 0}, {1, 0}}) do
        local nx, ny = x + dir[1], y + dir[2]
        if nx >= 1 and nx <= server.GRID_SIZE and ny >= 1 and ny <= server.GRID_SIZE then
            local cell = grid[ny][nx]
            if cell.tunnelId then table.insert(neighbors, cell.tunnelId) end
        end
    end

    local id = server.tunnelIdCounter
    if #neighbors == 0 then
        server.tunnelStats[id] = {tileCount = 0, exitScore = 0}
        server.tunnelIdCounter = server.tunnelIdCounter + 1
    else
        id = neighbors[1]
        local toMerge = {}
        for _, tid in ipairs(neighbors) do if tid ~= id then toMerge[tid] = true end end
        if next(toMerge) then
            common.mergeTunnels(server.grid, server.tunnelStats, id, toMerge)
        end
    end

    grid[y][x].tunnelId = id
    server.tunnelStats[id].tileCount = server.tunnelStats[id].tileCount + 1
    server.tunnelStats[id].exitScore = server.tunnelStats[id].exitScore + common.getExitDelta(tileType)
end

--–í–∏–ø–∞–¥–∫–æ–≤–∞ –∫–∞—Ä—Ç–∞
function server.drawRandomCard()
    local types = { "straight", "cross", "t", "corner", "deadend", "empty" }
    return {
        type = types[math.random(#types)],
        rotation = 0,
        x = 0, y = 0, hover = false
    }
end

--–ö–æ–ø—ñ—é–≤–∞–Ω–Ω—è —Å—ñ—Ç–∫–∏
function deepCopyGrid(grid)
    local copy = {}
    for y = 1, #grid do
        copy[y] = {}
        for x = 1, #grid[y] do
            local c = grid[y][x]
            copy[y][x] = {
                type = c.type,
                rotation = c.rotation,
                tunnelId = c.tunnelId,
                occupied = c.occupied
            }
        end
    end
    return copy
end

server.start()

logger.log("–°–µ—Ä–≤–µ—Ä –ø–æ–≤–Ω—ñ—Å—Ç—é –∑–∞–ø—É—â–µ–Ω–æ —ñ –ø—Ä–∞—Ü—é—î.")
while true do
    local success, err = pcall(server.update)
    if not success then
        logger.log("–ü–æ–º–∏–ª–∫–∞ —É server.update: " .. tostring(err))
    end
    socket.sleep(0.05) -- –ø–æ–∑–≤–æ–ª—è–µ—Ç CPU –æ—Ç–¥–æ—Ö–Ω—É—Ç—å
end